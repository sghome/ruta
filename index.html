<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAZECO Logo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script>
        let message = "HAZECO";
        let fontSize = 500;
        let rangeX = 0.2;
        let rangeY = 0.2;
        let lineMultiplication = 10;
        let lineOpacity = 0.6;
        let lineWidth = 0.3;
        let randomness = 0.2;
        let crop = 0;

        let messageSize;
        let font;
        let finalWidth;
        let pointsIn, pointsOut;
        let lettersImages;

        function preload() {
            font = loadFont('BebasNeue-Regular.ttf');
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1);
            noStroke();
            fill(0);
            
            messageSize = Math.hypot(windowWidth, windowHeight) / Math.hypot(1920, 1080) * fontSize
            crop = floor(map(0, 0, 1, 0, messageSize/2*0.8));
            
            textFont(font);
            textSize(messageSize);
            
            let x = 0;
            finalWidth = textWidth(message);
            
            [...message].forEach(char => {
                let tW = ceil(textWidth(char));
                let graph = createGraphics(tW, messageSize);
                graph.textFont(font);
                graph.textSize(messageSize);
                graph.textAlign(CENTER, CENTER);
                graph.text(char, graph.width/2, graph.height/2*0.8);
                graph.x = round(x);
                lettersImages.push(graph);
                graph.loadPixels();
                
                const pD = graph.pixelDensity();
                const yIn = (graph.width * pD) * floor((graph.height/2 - crop) * pD) * 4;
                const yOut = (graph.width * pD) * floor((graph.height/2 + crop) * pD) * 4;
                for(let i = 0; i < graph.width; i++){
                    const alphaIndexIn = i * 4 * pD + yIn + 3;
                    const alphaIndexOut = i * 4 * pD + yOut + 3;
                    let alphaIn = graph.pixels[alphaIndexIn];
                    let alphaOut = graph.pixels[alphaIndexOut];
                    if(alphaIn > 100){
                        pointsIn.push({
                            x: i + x,
                            y: graph.height/2 - crop
                        });
                    }
                    if(alphaOut > 100){
                        pointsOut.push({
                            x: i + x,
                            y: graph.height/2 + crop
                        });
                    }
                }
                
                x += tW;
            });
        }

        function draw(){
            background(255);
            randomSeed(0);
            
            let distX = mouseX / width;
            let distY = mouseY / height;
            let startX = round((width - finalWidth) * distX);
            let endX = round((width - finalWidth) * (1-distX));
            let startY = height * distY;
            let endY = height * (1-distY);
            
            //draw letters
            lettersImages.forEach(graph => {
                image(graph, round(graph.x + startX), startY, graph.width, graph.height/2 - crop, 0, 0, graph.width, graph.height/2 - crop);

                let xx = graph.x + endX;
                let yy = endY - graph.height/2;
                image(graph, xx, yy, graph.width, graph.height, 0, graph.height/2 + crop, graph.width, graph.height + crop);
            });
            
            if(pointsIn.length == 0 || pointsOut.length == 0)
                return;
            
            //draw connections
            strokeWeight(lineWidth);
            stroke(0);
            const gradient = drawingContext.createLinearGradient(startX, startY + lettersImages[0].height/2, startX, endY - lettersImages[0].height/2);
            gradient.addColorStop(0, "black");
            gradient.addColorStop(0.3, "rgba(0, 0, 0, " + lineOpacity + ")");
            gradient.addColorStop(0.5, "rgba(0, 0, 0, " + (lineOpacity*lineOpacity) + ")");
            gradient.addColorStop(0.7, "rgba(0, 0, 0, " + lineOpacity + ")");
            gradient.addColorStop(1, "black");
            drawingContext.strokeStyle = gradient;
            noFill();
            pointsIn.forEach((coord, index) => {
                for(var d = 0; d < lineMultiplication; d++){
                    const endCoord = random() > randomness ? pointsOut[floor(map(index, 0, pointsIn.length, 0, pointsOut.length))] : random(pointsOut);
                    const controlY = random(-rangeY, rangeY);
                    const anchorX1 = coord.x + startX + 0.5;
                    const anchorY1 = coord.y + startY - 1;
                    const anchorX2 = endCoord.x + endX + 0.5;
                    const anchorY2 = endY - endCoord.y + 1 + crop;
                    const controlX1 = lerp(anchorX1, width/2, random(rangeX));
                    const controlY1 = lerp(anchorY1, anchorY2, 0.8 + controlY);
                    const controlX2 = lerp(anchorX2, width/2, random(rangeX));
                    const controlY2 = lerp(anchorY1, anchorY2,  0.2 + controlY);
                    bezier(anchorX1, anchorY1,
                                    controlX1, controlY1,
                                    controlX2, controlY2,
                                    anchorX2, anchorY2);
                }
            })
        }
    </script>
</body>
</html>
